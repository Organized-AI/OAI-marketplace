/**
 * Export Generator
 *
 * Generates Claude Code configuration files from Stack Builder components.
 * Produces CLAUDE.md, settings.json, command files, and MCP configurations.
 */

// =============================================================================
// Type Definitions
// =============================================================================

/**
 * Component types supported by the Stack Builder
 */
export type StackComponentType = 'agent' | 'mcp' | 'hook' | 'command' | 'setting';

/**
 * Represents a component from the Stack Builder canvas
 */
export interface StackComponent {
  id: string;
  type: StackComponentType;
  name: string;
  config?: Record<string, unknown>;
  prompt?: string;
  description?: string;
}

/**
 * Represents a file to be exported
 */
export interface ExportFile {
  path: string;
  content: string;
}

/**
 * Result of the export generation process
 */
export interface ExportResult {
  files: ExportFile[];
  installCommands: string[];
  mcpConfigs: Record<string, unknown>;
}

// =============================================================================
// Main Export Function
// =============================================================================

/**
 * Generates export files from Stack Builder components
 *
 * @param components - Array of components from the canvas
 * @param projectName - Name of the project for file headers
 * @returns ExportResult with files, install commands, and MCP configs
 */
export function generateExport(
  components: StackComponent[],
  projectName: string
): ExportResult {
  // Separate components by type
  const agents = components.filter((c) => c.type === 'agent');
  const mcps = components.filter((c) => c.type === 'mcp');
  const hooks = components.filter((c) => c.type === 'hook');
  const commands = components.filter((c) => c.type === 'command');
  const settings = components.filter((c) => c.type === 'setting');

  // Initialize result collections
  const files: ExportFile[] = [];
  const installCommands: string[] = [];
  const mcpConfigs: Record<string, unknown> = {};

  // Generate CLAUDE.md
  files.push({
    path: '.claude/CLAUDE.md',
    content: generateClaudeMd(projectName, agents, mcps),
  });

  // Generate settings.json
  files.push({
    path: '.claude/settings.json',
    content: JSON.stringify(generateSettingsJson(settings, hooks), null, 2),
  });

  // Generate command files
  commands.forEach((cmd) => {
    const filename = cmd.name.toLowerCase().replace(/\s+/g, '-');
    files.push({
      path: `.claude/commands/${filename}.md`,
      content: generateCommandFile(cmd),
    });
  });

  // Handle MCP configurations
  mcps.forEach((mcp) => {
    if (mcp.config?.installCommand) {
      installCommands.push(mcp.config.installCommand as string);
    }
    if (mcp.config?.mcpConfig) {
      mcpConfigs[mcp.id] = mcp.config.mcpConfig;
    }
  });

  // Add mcp.json if there are MCP configs
  if (Object.keys(mcpConfigs).length > 0) {
    files.push({
      path: '.claude/mcp.json',
      content: JSON.stringify({ mcpServers: mcpConfigs }, null, 2),
    });
  }

  return { files, installCommands, mcpConfigs };
}

// =============================================================================
// File Generators (implemented in subsequent prompts)
// =============================================================================

/**
 * Generates CLAUDE.md content for the project
 */
function generateClaudeMd(
  projectName: string,
  agents: StackComponent[],
  mcps: StackComponent[]
): string {
  const lines: string[] = [];

  // Header
  lines.push(`# ${projectName}`);
  lines.push('');
  lines.push('## Project Overview');
  lines.push('This project uses Claude Code with the following configuration.');
  lines.push('');

  // Agents section
  if (agents.length > 0) {
    lines.push('## Agents');
    lines.push('');
    agents.forEach((agent) => {
      lines.push(`### ${agent.name}`);
      lines.push(agent.description || 'No description provided.');
      lines.push('');
      if (agent.prompt) {
        lines.push(agent.prompt);
        lines.push('');
      }
    });
  }

  // MCPs section
  if (mcps.length > 0) {
    lines.push('## Available Tools (MCPs)');
    lines.push('');
    mcps.forEach((mcp) => {
      lines.push(`- **${mcp.name}**: ${mcp.description || 'No description'}`);
    });
    lines.push('');
  }

  // Usage section
  lines.push('## Usage');
  lines.push('');
  lines.push('This configuration was generated by [Organized AI Stack Builder](https://stack.organizedai.vip).');
  lines.push('');
  lines.push('To use this configuration:');
  lines.push('1. Copy the `.claude/` directory to your project root');
  lines.push('2. Run any MCP install commands if needed');
  lines.push('3. Start Claude Code in this directory');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generates settings.json content for Claude Code configuration
 */
function generateSettingsJson(
  settings: StackComponent[],
  hooks: StackComponent[]
): Record<string, unknown> {
  // Start with base config
  const config: Record<string, unknown> = {
    version: '1.0',
    generatedBy: 'Organized AI Stack Builder',
    generatedAt: new Date().toISOString(),
  };

  // Apply settings - merge each setting's config into the main config
  settings.forEach((setting) => {
    if (setting.config) {
      Object.assign(config, setting.config);
    }
  });

  // Apply hooks
  if (hooks.length > 0) {
    const hooksConfig: Record<string, unknown> = {};

    hooks.forEach((hook) => {
      if (hook.config?.hookType && hook.config?.script) {
        hooksConfig[hook.config.hookType as string] = hook.config.script;
      }
    });

    if (Object.keys(hooksConfig).length > 0) {
      config.hooks = hooksConfig;
    }
  }

  return config;
}

/**
 * Generates a command markdown file for Claude Code
 */
function generateCommandFile(command: StackComponent): string {
  const lines: string[] = [];

  // Header
  lines.push(`# ${command.name}`);
  lines.push('');

  // Description
  if (command.description) {
    lines.push(command.description);
    lines.push('');
  }

  // Prompt/Instructions
  if (command.prompt) {
    lines.push(command.prompt);
  } else {
    lines.push('## Instructions');
    lines.push('');
    lines.push(`Execute the ${command.name} workflow.`);
  }
  lines.push('');

  return lines.join('\n');
}

// =============================================================================
// ZIP Generation
// =============================================================================

/**
 * Generates a ZIP blob from export files
 * Uses dynamic import for jszip to support server-side rendering
 *
 * @param files - Array of export files to include in the ZIP
 * @returns Promise resolving to a Blob containing the ZIP
 */
export async function generateZip(files: ExportFile[]): Promise<Blob> {
  const JSZip = (await import('jszip')).default;
  const zip = new JSZip();

  files.forEach((file) => {
    zip.file(file.path, file.content);
  });

  return await zip.generateAsync({ type: 'blob' });
}
